plugins {
    id "war"
    id "idea"
    id "de.undercouch.download" version "3.2.0"
}

group "$groupName"

repositories {
    mavenCentral()
}

/**
 * Set sources for integration tests
 */
sourceSets {
    test {
        java.srcDir 'src/test/unit/java'
        resources.srcDir 'src/test/unit/resources'
    }
    integration {
        java.srcDir 'src/test/integration/java'
        resources.srcDir 'src/test/integration/resources'
        compileClasspath += main.output + test.output
        runtimeClasspath += main.output + test.output
    }
}
configurations {
    integrationCompile.extendsFrom testCompile
    integrationRuntime.extendsFrom testRuntime
}

/**
 * Idea config
 */
idea {
    module {
        testSourceDirs = [
                file('src/test/integration/java'),
                file('src/test/unit/java')
        ]
        scopes.TEST.plus += [configurations.integrationCompile]
    }
}

/**
 * Compile dependencies
 */
dependencies {
    compile(
            "org.apache.logging.log4j:log4j-core:$log4jVersion",
            "org.apache.logging.log4j:log4j-api:$log4jVersion",
            "org.apache.logging.log4j:log4j-slf4j-impl:$log4jVersion",
            "org.slf4j:slf4j-api:$slf4jApiVersion",
            "com.google.guava:guava:$guavaVersion",
            "org.reflections:reflections:$reflectionsVersion",
            "com.fasterxml.jackson.datatype:jackson-datatype-jaxrs:$fastXmlJackson",
            "com.fasterxml.jackson.datatype:jackson-datatype-jdk8:$fastXmlJackson",
            "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:$fastXmlJackson",
            "com.fasterxml.jackson.core:jackson-databind:$fastXmlJackson",
            "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider:$fastXmlJackson",
    )
    providedCompile "javax:javaee-api:$javaEEApiVersion"
    testCompileOnly "javax:javaee-api:$javaEEApiVersion"
    testCompile(
            "org.apache.logging.log4j:log4j-core:$log4jVersion",
            "org.apache.logging.log4j:log4j-api:$log4jVersion",
            "org.powermock:powermock-module-junit4:$powerMockVersion",
            "org.powermock:powermock-module-junit4-rule:$powerMockVersion",
            "org.powermock:powermock-api-mockito:$powerMockVersion",
            "org.powermock:powermock:$powerMockVersion",
            "org.mockito:mockito-core:$mockitoVersion",
            "junit:junit:$jUnitVersion"
    )
    integrationCompile(
            "fish.payara.extras:payara-embedded-all:$pmv",
            "org.jboss.arquillian.junit:arquillian-junit-container:$junitArquillian",
            "org.jboss.arquillian.container:arquillian-glassfish-embedded-3.1:$glassfishEmbedded",
            "org.glassfish.jersey.core:jersey-client:$jerseyVersion"
    )
}

/**
 * Configs
 */
ext {
    dockerName = "${group}/${war.baseName}:${version}_${env}"
    dockerStartupName = "${war.baseName}_${version}_${port}"
    warName = "${war.baseName}-$version"
    dockerDir = "${project.buildDir}/docker"
    warDir = "${project.buildDir}/libs"
    awsS3File = "Dockerrun.aws.${rootProject.name}_${env}_${version}.json"
    awsVersionLabel = "${rootProject.name}_${env}_${version}"
}

/**
 * Download payara micro
 */
task downloadPayaraMicro {
    doFirst {
        download {
            src "http://central.maven.org/maven2/fish/payara/extras/payara-micro/${pmv}/payara-micro-${pmv}.jar"
            dest "$projectDir/payara-micro.jar"
        }
    }
}
/**
 * Build configuration environment
 */
task buildConfig(type: Copy) {
    from("src/main/resources/${env}.properties") {
        rename "${env}.properties", "config.properties"
    }
    from("src/main/resources/${env}.log4j2.xml") {
        rename "${env}.log4j2.xml", "log4j2.xml"
    }
    doFirst {
        println("${color_yellow}#### BUILD " + env + "${color_end}")
    }
    into sourceSets.main.output.resourcesDir
    doLast {
        Properties props = new Properties()
        File propsFile = new File("${sourceSets.main.output.resourcesDir}/config.properties")
        props.load(propsFile.newDataInputStream())
        props.setProperty("version", version.toString())
        props.setProperty("applicationName", rootProject.name)
        props.store(propsFile.newWriter(), null)
        mkdir dockerDir
    }
}

tasks.compileJava.dependsOn buildConfig
tasks.war.dependsOn buildConfig
/**
 * Remove docker image
 */
task removeDocker(type: Exec) {
    commandLine "docker", "rmi", "--force", "${dockerName}"
}

/**
 *  Prepare docker files for buildDocker
 */
task prepareDockerFiles(type: Copy, dependsOn: war) {
    println("$dockerDir/${warName}.war")
    from("$warDir/${warName}.war") {
        rename "${warName}.war", "app.war"
    }
    from file("Dockerfile")
    into dockerDir
    outputs.dir dockerDir
}
/**
 * Bake docker image
 */
task buildDocker(type: Exec, dependsOn: prepareDockerFiles) {
    standardOutput = new ByteArrayOutputStream()
    executable "docker"
    args = ["build", "-t", "${dockerName}", "${dockerDir}"]
    ext.output = {
        return 0
    }
    doFirst {
        println("${color_yellow}DOCKER DIR $dockerDir ${color_end}")
    }
    doLast {
        println(standardOutput.toString())
    }
    outputs.upToDateWhen {
        return !tasks.prepareDockerFiles.getDidWork()
    }
}
/**
 * Start docker container
 */
task startDocker(type: Exec, dependsOn: buildDocker) {
    commandLine "docker", "run", "-d", "-p", "${port}:${payaraPort}", "--name", "${dockerStartupName}", "${dockerName}"
    doFirst {
        println("${color_yellow}Docker compose start${color_end}")
        tasks.dockerCompose.execute()
    }
}

/**
 * Docker remove
 */
task stopDocker(type: Exec) {
    commandLine "docker", "rm", "-f", "${dockerStartupName}"
    doLast {
        println("${color_yellow}Docker compose down${color_end}")
        tasks.dockerComposeDown.execute()
    }
}

/**
 *  Remove docker image
 */
task dockerRemoveImage(type: Exec) {
    standardOutput = new ByteArrayOutputStream()
    commandLine "docker", "rmi", "${dockerName}", "--force"
    ext.output = {
        return 0
    }
}

/**
 *  Docker compose start containers
 */
task dockerCompose(type: Exec) {
    commandLine "docker-compose", "up", "-d"
}
/**
 *  Docker compose stop containers
 */
task dockerComposeDown(type: Exec) {
    standardOutput = new ByteArrayOutputStream()
    executable "docker-compose"
    args = [ "down" ]
    ext.output = {
        return 0
    }
}

/**
 * Start payara micro server
 */
task startServer(type: Exec, dependsOn: war) {
    commandLine "java", "-jar", "./payara-micro.jar", "--deploy", "$warDir/${warName}.war", "--noCluster", "true"
    doFirst {
        if (!file("./payara-micro.jar").exists()) {
            tasks.downloadPayaraMicro.execute()
        }
    }
}

/**
 * Testing unit tests configuration
 */
test {
    scanForTestClasses = true
    include '**/*Test.class'
    maxParallelForks = 4
    testLogging {
        showStandardStreams = true
        exceptionFormat "full"
        events = ["started", "passed", "skipped", "failed", "standard_out", "standard_error"]
        showExceptions = true
        showStackTraces = true
    }
    outputs.upToDateWhen { false }
    afterTest { desc, result ->
        println "${color_blue}Executing unit test ${desc.name} [${desc.className}] with result: ${result.resultType}${color_end}"
    }
    doFirst {
        println("${color_green}starting unit test ${color_end}")
    }
}

/**
 * Integration testing configuration
 */
task itest(type: Test) {
    System.setProperty "http.port", port
    scanForTestClasses = true
    include '**/*Test.class'
    maxParallelForks = 1
    testLogging {
        showStandardStreams = true
        exceptionFormat "full"
        events = ["started", "passed", "skipped", "failed", "standard_out", "standard_error"]
        showExceptions = true
        showStackTraces = true
    }
    afterTest { desc, result ->
        println "${color_blue}Executing integration test ${desc.name} [${desc.className}] with result: ${result.resultType}${color_end}"
    }
    outputs.upToDateWhen { false }
    doFirst {
        println("${color_green}starting integration test ${color_end}")
    }
    // set class path and pass args
    systemProperties = System.properties
    testClassesDir = sourceSets.integration.output.classesDir
    classpath = sourceSets.integration.runtimeClasspath
}

tasks.itest.dependsOn dockerCompose
tasks.itest.finalizedBy dockerComposeDown
/**
 * Json
 */
import groovy.json.JsonBuilder
import groovy.json.JsonSlurper

/**
 * Create ebs version
 */
task createEBSVersion {
    ext.ebsVersionName = "Dockerrun.aws.${war.baseName}_${env}_${version}.json"
    doLast {
        def json = new JsonSlurper().parse(
                """
            {
              "AWSEBDockerrunVersion": "1",
              "Image": {
                "Name": null,
                "Update": "true"
              },
              "Ports": [
                {
                  "HostPort": 80,
                  "ContainerPort": ${payaraPort}
                }
              ]
            }
            """.toCharArray()
        )
        json.Image.Name = "${awsECR}:${version}_${env}"
        File dockerRun = file(ebsVersionName)
        dockerRun.write(new JsonBuilder(json).toPrettyString())
    }
}

tasks.createEBSVersion.mustRunAfter buildDocker
/**
 * Login to aws
 */
task loginToAws(type: Exec) {
    standardOutput = new ByteArrayOutputStream()
    commandLine "aws", "ecr", "get-login", "--region", "$awsRegion"
    doLast {
        List<String> commands = standardOutput.toString().split("\\s")
        String command = commands.remove(0)
        exec {
            executable command
            args commands
        }
    }
}

/**
 * Check ebs version
 */
task checkEBSVersion(type: Exec, dependsOn: loginToAws) {
    standardOutput = new ByteArrayOutputStream()
    commandLine "aws", "elasticbeanstalk", "describe-application-versions", "--application-name", "$awsEBSApp", "--version-label", "$awsVersionLabel", "--region", "$awsRegion"
    doFirst {
        println("${color_yellow} CHECK $awsEBSApp -> $awsVersionLabel -> $awsRegion ${color_end}")
    }
    doLast {
        byte[] bytes = standardOutput.toByteArray()
        println("${color_yellow}VERSIONS")
        println(standardOutput.toString())
        println("${color_end}")
        def json = new JsonSlurper().parse(bytes)
        if (json != null && json.ApplicationVersions != null && json.ApplicationVersions.size() > 0) {
            throw new Error("VERSION EXISTS!!!")
        }
    }
    ext.output = {
        return 0
    }
}

tasks.checkEBSVersion.mustRunAfter createEBSVersion
/**
 * Create docker build and ecr tags
 */
task createECRDockerTags(type: Exec, dependsOn: [buildDocker, createEBSVersion, checkEBSVersion]) {
    commandLine "docker", "tag", "$dockerName", "$awsECR:${version}_${env}"
    doFirst {
        if (env.equals("prod")) {
            exec {
                commandLine "docker", "tag", "$dockerName", "$awsECR:latest"
            }
        }
    }
}
/**
 * Create s3 ECR version
 */
task createS3ECRVersion(type: Exec, dependsOn: createECRDockerTags) {
    commandLine "aws", "s3", "cp", "./$awsS3File", "s3://$awsEBSBucket/$awsS3File", "--region", "$awsRegion"
}

tasks.createS3ECRVersion.mustRunAfter clean
/**
 * publish to ecr
 */
task publishToECR(type: Exec, dependsOn: [clean, createS3ECRVersion]) {
    executable "aws"
    args = [
            "elasticbeanstalk",
            "create-application-version",
            "--application-name",
            "$awsEBSApp",
            "--version-label",
            "$awsVersionLabel",
            "--source-bundle",
            "S3Bucket=$awsEBSBucket,S3Key=$awsS3File",
            "--region",
            "$awsRegion"
    ]
    doFirst {
        exec {
            commandLine "docker", "push", "$awsECR:${version}_${env}"
        }
        if (env.equals("prod")) {
            exec {
                commandLine "docker", "push", "$awsECR:latest"
            }
        }
    }
}
