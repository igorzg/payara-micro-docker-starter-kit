plugins {
    id "war"
    id "de.undercouch.download" version "3.2.0"
}

group "microservice"

repositories {
    mavenCentral()
}

/**
 * Set sources for integration tests
 */
sourceSets {
    integration {
        java.srcDir 'src/test/java'
        resources.srcDir 'src/test/resources'
        compileClasspath += main.output + test.output
        runtimeClasspath += main.output + test.output
    }
}
configurations {
    integrationCompile.extendsFrom testCompile
    integrationRuntime.extendsFrom testRuntime
}

/**
 * Compile dependencies
 */
dependencies {

    String powerMockVersion = "1.6.6"
    String mockitoVersion = "1.10.19"
    String jUnitVersion = "4.12"
    String log4jVersion = "2.7"
    String guavaVersion = "21.0"
    String jasksonJsonVersion = "2.8.7"
    String jersyJacksonVersion = "2.25.1"
    String javaEEApiVersion = "7.0"
    String reflectionsVersion = "0.9.10"

    compile(
            "org.apache.logging.log4j:log4j-core:$log4jVersion",
            "org.apache.logging.log4j:log4j-api:$log4jVersion",
            "org.reflections:reflections:$reflectionsVersion",
            "com.google.guava:guava:$guavaVersion",
            "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider:$jasksonJsonVersion"
    )
    providedCompile "javax:javaee-api:$javaEEApiVersion"
    testCompileOnly "javax:javaee-api:$javaEEApiVersion"
    testCompile(
            "org.apache.logging.log4j:log4j-core:$log4jVersion",
            "org.apache.logging.log4j:log4j-api:$log4jVersion",
            "org.powermock:powermock-module-junit4:$powerMockVersion",
            "org.powermock:powermock-module-junit4-rule:$powerMockVersion",
            "org.powermock:powermock-api-mockito:$powerMockVersion",
            "org.powermock:powermock:$powerMockVersion",
            "org.mockito:mockito-core:$mockitoVersion",
            "junit:junit:$jUnitVersion"
    )
    integrationCompile(
            "org.glassfish.jersey.core:jersey-client:$jersyJacksonVersion"
    )
}


/**
 * Configs
 */
ext {
    dockerName = "${group}/${war.baseName}:${version}_${env}"
    dockerStartupName = "${war.baseName}_${version}_${port}"
    warName = "${war.baseName}-$version"
    dockerDir = "${project.buildDir}/docker"
    warDir = "${project.buildDir}/libs"
}

/**
 * Download payara micro
 */
task downloadPayaraMicro {
    String pmv = "4.1.1.171.0.1"
    doFirst {
        download {
            src "http://central.maven.org/maven2/fish/payara/extras/payara-micro/${pmv}/payara-micro-${pmv}.jar"
            dest "$projectDir/payara-micro.jar"
        }
    }
}
/**
 * Build configuration environment
 */
task buildConfig(type: Copy) {
    from("src/main/resources/environments/${env}.properties") {
        rename "${env}.properties", "config.properties"
    }
    into sourceSets.main.output.resourcesDir
    doLast {
        Properties props = new Properties()
        File propsFile = new File("${sourceSets.main.output.resourcesDir}/config.properties")
        props.load(propsFile.newDataInputStream())
        props.setProperty("version", version.toString())
        props.store(propsFile.newWriter(), null)
        mkdir dockerDir
    }
}

tasks.compileJava.dependsOn buildConfig
tasks.war.dependsOn buildConfig
/**
 * Remove docker image
 */
task removeDocker(type: Exec) {
    commandLine "docker", "rmi", "--force", "${dockerName}"
}

/**
 *  Prepare docker files for buildDocker
 */
task prepareDockerFiles(type: Copy, dependsOn: war) {
    println("$dockerDir/${warName}.war")
    from("$warDir/${warName}.war") {
        rename "${warName}.war", "app.war"
    }
    from file("Dockerfile")
    into dockerDir
    outputs.dir dockerDir
}
/**
 * Bake docker image
 */
task buildDocker(type: Exec, dependsOn: prepareDockerFiles) {
    standardOutput = new ByteArrayOutputStream()
    executable "docker"
    args = ["build", "-t", "${dockerName}", "${dockerDir}"]
    ext.output = {
        return 0
    }
    doFirst {
        println("DOCKER DIR $dockerDir")
    }
    doLast {
        println(standardOutput.toString())
    }
    outputs.upToDateWhen {
        return !tasks.prepareDockerFiles.getDidWork()
    }
}
/**
 * Start docker container
 */
task startDocker(type: Exec, dependsOn: buildDocker) {
    commandLine "docker", "run", "-d", "-p", "${port}:8080", "--name", "${dockerStartupName}", "${dockerName}"
}

/**
 * Stop docker and remove container
 */
task stopDocker(type: Exec) {
    commandLine "docker", "rm", "-f", "${dockerStartupName}"
}

/**
 * Start payara micro server
 */
task startServer(type: Exec, dependsOn: war) {
    commandLine "java", "-jar", "./payara-micro.jar", "--deploy", "$warDir/${warName}.war", "--noCluster", "true"
    doFirst {
        if (!file("./payara-micro.jar").exists()) {
            tasks.downloadPayaraMicro.execute()
        }
    }
}

/**
 * Testing unit tests configuration
 */
test {
    scanForTestClasses = true
    include 'unit/**/*Test.class'
    maxParallelForks = 4
    testLogging {
        showStandardStreams = true
        exceptionFormat "full"
        events = ["started", "passed", "skipped", "failed", "standard_out", "standard_error"]
        showExceptions = true
        showStackTraces = true
    }
    afterTest { desc, result ->
        println "Executing test ${desc.name} [${desc.className}] with result: ${result.resultType}"
    }
}

/**
 * Integration testing configuration
 */
task itest(type: Test) {
    System.setProperty "http.port", port
    scanForTestClasses = true
    include 'integration/**/*Test.class'
    maxParallelForks = 4
    testLogging {
        showStandardStreams = true
        exceptionFormat "full"
        events = ["started", "passed", "skipped", "failed", "standard_out", "standard_error"]
        showExceptions = true
        showStackTraces = true
    }
    afterTest { desc, result ->
        println "Executing test ${desc.name} [${desc.className}] with result: ${result.resultType}"
    }
    outputs.upToDateWhen { false }
    doFirst {
        println("STARTING IT TEST")
    }
    // set class path and pass args
    systemProperties = System.properties
    testClassesDir = sourceSets.integration.output.classesDir
    classpath = sourceSets.integration.runtimeClasspath
}

/**
 * Integration test in docker
 */
task itestInDocker(type: Exec, dependsOn: startDocker) {
    commandLine "gradle", "itest"
    doFirst {
        println("Waiting ${serverStartupTime} sec to deploy app in docker container")
        sleep(Integer.parseInt(serverStartupTime) * 1000)
    }
    finalizedBy stopDocker
}